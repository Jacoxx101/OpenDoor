<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenDoor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <style>
        :root {
            /* Original theme variables */
            --bg: #ffffff;
            --border: #e5e7eb;
            --text: #111111;
            --text-light: #666666;
            --primary: #000000;
            --primary-hover: #333333;
            --input-bg: #f0f0f0;
            --message-bg: #f9fafb;
            --sidebar-bg: #f9fafb;
            --sidebar-border: #e5e7eb;
            --sidebar-width: 220px;
            --sidebar-collapsed-width: 72px;
            
            /* New composer theme tokens */
            --panel: #f9fafb;
            --panel-2: #f5f5f7;
            --muted: #666666;
            --border-2: #d1d5db;
            --chip: #e5e7eb;
            --chip-hover: #d1d5db;
            --accent: #3b82f6;
            --radius: 14px;
            --radius-sm: 10px;
        }

        [data-theme="dark"] {
            /* Original dark theme variables */
            --bg: #0f0f10;
            --border: #2d2f33;
            --text: #f2f2f2;
            --text-light: #a3a3ad;
            --primary: #ffffff;
            --primary-hover: #cccccc;
            --input-bg: #1a1b1e;
            --message-bg: #202125;
            --sidebar-bg: #181818;
            --sidebar-border: #333333;
            
            /* New dark composer theme tokens */
            --panel: #1a1b1e;
            --panel-2: #202125;
            --muted: #a3a3ad;
            --border-2: #3a3d42;
            --chip: #23252a;
            --chip-hover: #2a2d33;
            --accent: #3b82f6;
            --radius: 14px;
            --radius-sm: 10px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Screen reader only text */
        .sr-only { 
            position: absolute; 
            width: 1px; 
            height: 1px; 
            padding: 0; 
            margin: -1px; 
            overflow: hidden; 
            clip: rect(0,0,0,0); 
            white-space: nowrap; 
            border: 0; 
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: row;
        }

        /* Header */
        .header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .title {
            font-size: 1.125rem;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .title:hover {
            opacity: 0.7;
        }

        .logo {
            width: 34px;
            height: 34px;
            border-radius: 0.5rem;
            object-fit: cover;
        }

        .api-btn {
            padding: 0.5rem 1rem;
            background: none;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            color: var(--text-light);
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .api-btn:hover {
            border-color: var(--text);
            color: var(--text);
        }

        .api-btn.connected {
            color: #10b981;
            border-color: #10b981;
        }

        /* Model Selection */
        .model-selector {
            margin-right: 1rem;
            position: relative;
        }

        .model-select {
            padding: 0.5rem 2rem 0.5rem 0.75rem;
            background: var(--input-bg);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            color: var(--text);
            font-size: 0.875rem;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1rem;
            min-width: 140px;
        }

        .model-select:hover {
            border-color: var(--text);
        }

        .model-select:focus {
            outline: none;
            border-color: var(--text);
            background: var(--bg);
        }

        .model-label {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-bottom: 0.25rem;
            display: block;
        }

        /* Dark Mode Toggle */
        .theme-toggle {
            margin-right: 1rem;
            padding: 0.5rem;
            background: none;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
        }

        .theme-toggle:hover {
            border-color: var(--text);
            background: var(--input-bg);
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--sidebar-bg);
            border-right: 1px solid var(--sidebar-border);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            z-index: 10;
        }

        /* Mini mode */
        .sidebar.collapsed {
            width: var(--sidebar-collapsed-width);
        }
        .sidebar.collapsed .search-container,
        .sidebar.collapsed .chat-content,
        .sidebar.collapsed .new-chat-btn {
            display: none;
        }
        .sidebar.collapsed .sidebar-header {
            justify-content: center;
        }

        [data-theme="dark"] .sidebar {
            background: #181818 !important;
            border-right: 1px solid #333333 !important;
        }

        .sidebar.hidden {
            transform: translateX(-100%);
        }

        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--sidebar-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        [data-theme="dark"] .sidebar-header {
            border-bottom: 1px solid #333333 !important;
        }

        .new-chat-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--text);
            color: var(--sidebar-bg);
            border: none;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-right: 0.5rem;
        }

        .new-chat-btn:hover {
            opacity: 0.9;
        }

        .sidebar-toggle {
            padding: 0.5rem;
            background: none;
            border: 1px solid var(--sidebar-border);
            border-radius: 0.375rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
        }

        .sidebar-toggle:hover {
            background: var(--sidebar-bg);
            filter: brightness(0.95);
        }

        .search-container {
            padding: 1rem;
            border-bottom: 1px solid var(--sidebar-border);
        }

        [data-theme="dark"] .search-container {
            border-bottom: 1px solid #333333 !important;
        }

        .search-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--input-bg);
            color: var(--text);
            font-size: 0.875rem;
            outline: none;
            transition: all 0.2s;
        }

        .search-input::placeholder {
            color: var(--text-light);
        }

        .search-input:focus {
            border-color: var(--text);
        }

        .chat-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .chat-item {
            padding: 10px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chat-item:hover {
            background: var(--message-bg);
        }

        .chat-item.active {
            background: var(--text);
            color: var(--sidebar-bg);
        }

        .chat-item.active .chat-title {
            color: var(--sidebar-bg);
        }

        .chat-item.active .chat-date {
            color: var(--sidebar-bg);
            opacity: 0.8;
        }

        .chat-item.active .chat-menu-btn {
            color: var(--sidebar-bg);
        }

        .chat-title {
            font-size: 0.875rem;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
            color: var(--text);
            line-height: 1.2;
        }

        .chat-date {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 0.25rem;
            line-height: 1;
        }

        .chat-content {
            flex: 1;
            min-width: 0;
        }

        .chat-menu {
            opacity: 0;
            transition: opacity 0.2s;
        }

        .chat-item:hover .chat-menu {
            opacity: 1;
        }

        .chat-menu-btn {
            padding: 0.25rem;
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            border-radius: 0.25rem;
            transition: all 0.2s;
        }

        .chat-menu-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Chat Menu Dropdown */
        .chat-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 120px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
            transform: translateY(-10px);
        }

        .chat-dropdown.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .chat-dropdown-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background 0.2s;
            border-bottom: 1px solid var(--border);
        }

        .chat-dropdown-item:last-child {
            border-bottom: none;
        }

        .chat-dropdown-item:hover {
            background: var(--input-bg);
        }

        .chat-dropdown-item.danger {
            color: #dc2626;
        }

        .chat-dropdown-item.danger:hover {
            background: rgba(220, 38, 38, 0.1);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            height: 100vh;
            overflow: hidden;
        }

        /* Chat Area */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 900px;
            margin: 0 auto;
            width: 100%;
            padding: 0 1.5rem;
            overflow: hidden;
            min-height: 0;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.25rem 0;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            min-height: 0; /* Allow flex shrinking */
        }

        /* Spacing & readability */
        .message + .message {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .message .message-content p {
            margin: 0.5rem 0;
            line-height: 1.7;
        }

        /* Keep code blocks readable even without the card */
        .message .message-content pre {
            background: var(--input-bg);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
        }
        [data-theme="dark"] .message .message-content pre {
            background: #1f1f1f;
        }

        .message {
            display: flex;
            gap: 0.75rem;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 500;
            flex-shrink: 0;
        }

        .message.user .avatar {
            background: var(--text);
            color: white;
        }

        .message.assistant .avatar {
            background: var(--message-bg);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .message-content {
            flex: 1;
            line-height: 1.3;
            color: var(--text);
            max-width: 72ch;
        }

        /* --- Flat message override (no internal white box) --- */
        .message .message-content,
        .message.assistant .message-content,
        .message.ai .message-content,
        .response-card,
        .output-card {
            background: transparent !important;
            border: 0 !important;
            box-shadow: none !important;
            padding: 0 !important;
            border-radius: 0 !important;
        }

        /* Markdown styling for AI responses */
        .message-content h1,
        .message-content h2,
        .message-content h3 {
            margin: 1rem 0 0.5rem 0;
            color: var(--text);
        }

        .message-content h1 {
            font-size: 1.5rem;
            font-weight: 700;
            border-bottom: 2px solid var(--text);
            padding-bottom: 0.5rem;
            margin: 1.5rem 0 1rem 0;
            color: var(--text);
        }

        .message-content h2 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text);
            margin: 1.25rem 0 0.75rem 0;
            padding: 0.5rem 0;
            border-left: 4px solid var(--text);
            padding-left: 1rem;
        }

        .message-content h3 {
            font-size: 1.125rem;
            font-weight: 600;
            margin: 1rem 0 0.5rem 0;
            color: var(--text);
        }

        .message-content strong {
            font-weight: 700;
            color: var(--text);
        }

        .message-content em {
            font-style: italic;
            color: var(--text);
        }

        .message-content hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 2rem 0;
            width: 100%;
        }

        /* Code Blocks */
        .code-block {
            margin: 1rem 0;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            overflow: hidden;
            background: var(--input-bg);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: var(--border);
            border-bottom: 1px solid var(--border);
        }

        .code-lang {
            font-size: 0.75rem;
            color: var(--text-light);
            font-weight: 500;
        }

        .copy-btn {
            background: none;
            border: none;
            color: var(--text-light);
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: var(--input-bg);
            color: var(--text);
        }

        .code-block pre {
            margin: 0;
            padding: 1rem;
            overflow-x: auto;
            background: var(--input-bg);
        }

        .code-block code {
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        /* Inline Code */
        .inline-code {
            background: var(--input-bg);
            border: 1px solid var(--border);
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 0.875rem;
        }

        /* Blockquotes */
        .message-content blockquote {
            border-left: 4px solid var(--text);
            padding: 0.5rem 1rem;
            margin: 1rem 0;
            background: var(--input-bg);
            font-style: italic;
            color: var(--text-light);
        }

        /* Tables */
        .message-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .message-content th,
        .message-content td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .message-content th {
            background: var(--input-bg);
            font-weight: 600;
            color: var(--text);
        }

        .message-content tr:last-child td {
            border-bottom: none;
        }

        /* Zebra only on tbody so the header styling remains clean */
        .message-content tbody tr:nth-child(even) {
            background: var(--input-bg);
        }

        .message-content td.center {
            text-align: center;
        }

        .message-content td.right {
            text-align: right;
        }

        /* Recipe section styling */
        .message-content h2 + p,
        .message-content h2 + ul,
        .message-content h3 + p,
        .message-content h3 + ul {
            margin-top: 0.5rem;
        }

        /* Better paragraph spacing in recipe context */
        .message-content h3 + p + ul {
            margin-top: 0.75rem;
        }


        .message-content ul {
            margin: 0.75rem 0;
            padding-left: 0;
            list-style: none;
        }

        .message-content li {
            margin: 0.125rem 0;
            padding: 0 0 0 1.5rem;
            position: relative;
            line-height: 1.3;
        }

        .message-content li::before {
            content: "•";
            color: var(--text);
            font-weight: bold;
            position: absolute;
            left: 0.5rem;
        }

        .message-content ol {
            margin: 0.75rem 0;
            padding-left: 1.5rem;
            list-style: decimal;
        }

        .message-content ol li {
            padding-left: 0.5rem;
            margin: 0.125rem 0;
            line-height: 1.3;
            list-style-type: decimal;
        }

        .message-content ol li::before {
            display: none;
        }

        .message-content p {
            margin: 0.5rem 0;
            line-height: 1.6;
        }

        /* Give a tiny gap between any two blocks for readability */
        .message-content > * + * {
            margin-top: 0.25rem;
        }

        .message-content p:first-child {
            margin-top: 0;
        }

        .message-content p:last-child {
            margin-bottom: 0;
        }

        /* Input Area */
        .input-container {
            padding: 1.5rem 0;
            border-top: 1px solid var(--border);
            flex-shrink: 0; /* Prevent input from shrinking */
            background: var(--bg); /* Ensure background is visible */
        }

        .input-form {
            position: relative;
            max-width: 900px;
            margin: 0 auto;
        }

        /* =========================
           CHATGPT-STYLE COMPOSER
           ========================= */
        
        /* Composer */
        .composer{
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 14px;
            box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset, 0 4px 12px rgba(0,0,0,.15);
            position: relative;
            max-width: 980px;
            margin: 0 auto;
        }
        
        .chip-list{
            display: flex; 
            flex-wrap: wrap; 
            gap: 6px;
            margin-bottom: 6px;
        }

        /* File pill - slimmer */
        .chip{
            display: inline-flex; 
            align-items: center; 
            gap: 8px;
            background: var(--input-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 6px 8px 6px 6px;
            max-width: 100%;
        }
        
        .chip .doc{
            width: 20px; 
            height: 20px; 
            flex: 0 0 20px;
            display: grid; 
            place-items: center;
            border-radius: 6px;
            background: var(--panel-2);
            border: 1px solid var(--border);
        }
        
        .chip .meta{
            min-width: 0; /* enable truncation */
        }
        
        .chip .name{
            font-weight: 600;
            font-size: 13px;
            max-width: 420px;
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis;
        }
        
        .chip .desc{
            color: var(--muted);
            font-size: 12px;
        }
        
        .chip .remove{
            margin-left: 4px; 
            border: none;
            background: transparent; 
            color: var(--muted);
            width: 16px; 
            height: 16px; 
            border-radius: 4px;
            display: grid; 
            place-items: center; 
            cursor: pointer;
            opacity: 0.6;
        }
        
        .chip .remove:hover{
            opacity: 1;
            background: rgba(0,0,0,0.05);
        }

        /* Input row with toolbar */
        .input-row{
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            align-items: center;
        }
        
        .box{
            background: var(--panel-2);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 14px;
        }
        
        .box:focus-within{
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(122,162,255,.12);
        }
        
        .box textarea{
            width: 100%;
            min-height: 84px;
            max-height: 300px;
            resize: vertical;
            background: transparent;
            color: var(--text);
            border: 0; 
            outline: 0;
            font: 14px/1.5 "Inter",system-ui,Segoe UI,Roboto,Arial,sans-serif;
        }
        
        .box textarea::placeholder{ 
            color: var(--muted); 
        }

        .toolbar{
            display: flex; 
            flex-direction: column; 
            gap: 10px;
        }
        
        .tbtn{
            width: 36px; 
            height: 36px;
            background: var(--message-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            display: grid; 
            place-items: center;
            cursor: pointer;
            transition: background .12s ease, border-color .12s ease;
        }
        
        .tbtn:hover{ 
            background: var(--input-bg); 
        }
        
        .tbtn svg{ 
            width: 16px; 
            height: 16px; 
            opacity: 0.7;
        }
        
        .tbtn:hover svg{ 
            opacity: 1; 
        }

        /* Attach button (label for hidden input) */
        input[type="file"]{ 
            display:none; 
        }
        
        .attach{
            display: inline-flex; 
            align-items: center; 
            gap: 8px;
            padding: 8px 10px;
            border: 1px dashed var(--border);
            border-radius: 10px; 
            color: var(--muted);
            background: transparent;
            cursor: pointer;
        }
        
        .attach:hover{ 
            border-color: var(--border-2); 
            color: var(--text); 
        }
        
        /* Hide attach CTA when files are present */
        .chip-list:not(:empty) + .input-row + div .attach{
            display: none;
        }

        /* Drop overlay */
        .drop-hint {
            position: absolute;
            inset: 0;
            display: none;
            place-items: center;
            color: var(--text-light);
            font-weight: 600;
            pointer-events: none;
            border-radius: 16px;
            background: rgba(0,0,0,0.5);
        }

        .composer.dragging {
            border-color: var(--text);
            outline: 1px dashed var(--text);
            outline-offset: 4px;
        }

        .composer.dragging .drop-hint {
            display: grid;
        }

        /* compact mode */
        .wrap{ max-width: 860px; }                 /* narrower overall */
        .composer{ padding:10px 12px; border-radius:14px; }

        .chip-list{ margin-bottom:10px; }
        .chip{ padding:6px 8px; border-radius:10px; }
        .chip .name{ max-width: clamp(140px, 24vw, 360px); }

        .input-row{ gap:10px; }
        .box{ padding:8px 10px; border-radius:10px; }
        .box textarea{
            min-height:72px;          /* was ~100px */
            max-height:240px;
            line-height:1.45;
            font-size:14px;
        }

        .toolbar{ gap:8px; }
        .tbtn{
            width:36px; height:36px;  /* was 42x42 */
            border-radius:10px;
        }

        /* Mobile: toolbar goes horizontal */
        @media (max-width: 640px){
            .input-row{ 
                grid-template-columns: 1fr; 
            }
            .toolbar{ 
                flex-direction: row; 
            }
        }

        /* ===== Layout: move the content a bit left, not centered ===== */
        .wrap{
            --gutter: clamp(12px, 4vw, 40px);             /* left page padding */
            --column: min(820px, 100% - var(--gutter)*2); /* target width */
            width: var(--column);
            margin-left: var(--gutter);
            margin-right: auto;                            /* left align */
        }

        /* ===== Composer: smaller everything ===== */
        .composer{ padding:8px 10px; border-radius:12px; }

        /* file chip tighter */
        .chip-list{ margin-bottom:8px; }
        .chip{ padding:5px 7px; border-radius:9px; }
        .chip .name{ font-size:13px; max-width: clamp(120px, 22vw, 300px); }
        .chip .desc{ font-size:11px; }

        /* textarea compact */
        .box{ padding:6px 8px; border-radius:10px; }
        .box textarea{
            min-height:56px;          /* was big; now compact */
            max-height:180px;         /* still allows growth */
            font-size:13.5px;
            line-height:1.45;
        }

        /* right-rail buttons compact */
        .tbtn{ width:32px; height:32px; border-radius:9px; }
        .toolbar{ gap:8px; }

        /* if you *just* want a tiny extra nudge left (on top of the above) */
        @media (min-width: 900px){
            .wrap{ transform: translateX(-8px); }         /* "move a little left" */
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            color: var(--text-light);
        }

        .empty-state h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .empty-state p {
            margin-bottom: 2rem;
            color: var(--text);
        }

        .examples {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.75rem;
            width: 100%;
            max-width: 600px;
        }

        .example {
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            background: var(--input-bg);
            cursor: pointer;
            transition: all 0.2s;
        }

        .example:hover {
            border-color: var(--text);
            background: var(--bg);
        }

        .example h3 {
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
            color: var(--text);
        }

        .example p {
            font-size: 0.75rem;
            color: var(--text-light);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg);
            border-radius: 0.5rem;
            padding: 1.5rem;
            width: 90%;
            max-width: 400px;
            border: 1px solid var(--border);
        }

        .modal h2 {
            font-size: 1.125rem;
            margin-bottom: 1rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
            color: var(--text);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            background: var(--input-bg);
            font-family: inherit;
            outline: none;
            transition: all 0.2s;
        }

        .form-input:focus {
            border-color: var(--text);
            background: var(--bg);
        }

        .form-help {
            font-size: 0.75rem;
            color: var(--text-light);
            margin-top: 0.25rem;
        }

        .form-help a {
            color: var(--text);
            text-decoration: none;
        }

        .form-error {
            font-size: 0.75rem;
            color: #dc2626;
            margin-top: 0.25rem;
        }

        .modal-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            margin-top: 1.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .btn-secondary {
            background: var(--input-bg);
            color: var(--text);
            border: 1px solid var(--border);
        }

        .btn-primary {
            background: var(--text);
            color: var(--bg);
        }

        .btn:hover {
            opacity: 0.9;
        }

        .loading {
            display: inline-flex;
            gap: 2px;
        }

        .loading-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--text-light);
            animation: loading 1.4s infinite both;
        }

        .loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .loading-dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes loading {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        button, .model-select, .search-input, .input-textarea {
            outline: none;
        }
        button:focus-visible, .model-select:focus-visible,
        .search-input:focus-visible, .input-textarea:focus-visible {
            outline: 2px solid var(--text);
            outline-offset: 2px;
        }

        @media (max-width: 768px) {
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 1000;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .sidebar:not(.hidden) {
                transform: translateX(0);
            }

            .sidebar.hidden {
                transform: translateX(-100%);
            }

            .main-content {
                width: 100%;
            }

            .header {
                padding: 1rem;
            }

            .header-left {
                gap: 0.5rem;
            }

            .header-left .title span {
                display: none;
            }

            .model-selector {
                margin-right: 0.5rem;
            }

            .model-select {
                min-width: 100px;
            }
            
            .chat-container {
                padding: 0 0.75rem;
            }
            
            .examples {
                grid-template-columns: 1fr;
            }

            /* Mobile overlay when sidebar is open */
            .sidebar:not(.hidden)::after {
                content: '';
                position: fixed;
                top: 0;
                left: 250px;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: -1;
            }
        }

        @media (max-width: 480px) {
            .header {
                flex-direction: column;
                gap: 0.5rem;
                align-items: stretch;
                padding: 0.75rem;
            }

            .header-left {
                justify-content: space-between;
            }

            .header div:last-child {
                justify-content: space-between;
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            .model-selector {
                flex: 1;
                margin-right: 0;
            }

            .model-select {
                width: 100%;
                min-width: auto;
            }

            .sidebar {
                width: 100vw;
            }

            .new-chat-btn {
                font-size: 0.8rem;
                padding: 0.6rem 0.8rem;
            }

            .chat-item {
                padding: 0.6rem;
            }

            .chat-title {
                font-size: 0.8rem;
            }

            .chat-date {
                font-size: 0.7rem;
            }
            
            /* Mobile composer adjustments */
            .chips {
                padding: 6px 52px;
            }
            
            .chip {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <!-- API Key Modal -->
    <div class="modal-overlay" id="apiModal">
        <div class="modal">
            <h2>API Configuration</h2>
            <form id="apiForm">
                <div class="form-group">
                    <label class="form-label">Gemini API Key</label>
                    <input type="password" id="apiInput" class="form-input" placeholder="Enter your Gemini API key">
                    <div class="form-help">
                        Get your API key from <a href="https://makersuite.google.com/app/apikey" target="_blank">Google AI Studio</a>
                    </div>
                    <div class="form-error" id="apiError"></div>
                </div>
                <div class="form-group">
                    <label class="form-label">OpenRouter API Key (for GPT-5)</label>
                    <input type="password" id="openrouterInput" class="form-input" placeholder="Enter your OpenRouter API key">
                    <div class="form-help">
                        Get your API key from <a href="https://openrouter.ai/keys" target="_blank">OpenRouter</a>
                    </div>
                    <div class="form-error" id="openrouterError"></div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" id="cancelBtn">Cancel</button>
                    <button type="submit" class="btn btn-primary" id="saveBtn">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <button class="new-chat-btn" id="newChatBtn">+ New Chat</button>
            <button class="sidebar-toggle" id="sidebarToggle">⋮</button>
        </div>
        
        <div class="search-container">
            <input type="text" class="search-input" id="searchInput" placeholder="Search chats... (Cmd+K)">
        </div>
        
        <div class="chat-list" id="chatList">
            <!-- Chat history items will be populated here -->
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <button class="sidebar-toggle" id="mainSidebarToggle">☰</button>
                <div class="title" id="titleBtn">
                    <img src="857e0ceb-1f34-4d5b-b868-be32a87f2c69.png" alt="OpenDoor Logo" class="logo">
                    <span>OpenDoor</span>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 1rem;">
                <div class="model-selector">
                    <label class="model-label">Model</label>
                    <select class="model-select" id="modelSelect">
                        <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                        <option value="openai/gpt-5-chat">GPT-5 Chat</option>
                        <option value="qwen/qwen3-coder">Qwen 3 Coder</option>
                        <option value="z-ai/glm-4.5">GLM 4.5</option>
                    </select>
                </div>
                <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">🌙</button>
                <button class="api-btn" id="apiBtn" aria-label="Configure API key">API Key</button>
            </div>
        </div>

        <!-- Chat Container -->
        <div class="chat-container">
        <div class="messages" id="messages" role="log" aria-live="polite" aria-relevant="additions">
            <div class="empty-state" id="emptyState">
                <h2>Welcome to OpenDoor</h2>
                <p>Start a conversation with the AI assistant</p>
                <div class="examples">
                    <div class="example" data-prompt="Explain quantum computing simply">
                        <h3>Science</h3>
                        <p>Explain quantum computing simply</p>
                    </div>
                    <div class="example" data-prompt="Write a short story">
                        <h3>Creative</h3>
                        <p>Write a short story</p>
                    </div>
                    <div class="example" data-prompt="Plan a healthy meal">
                        <h3>Health</h3>
                        <p>Plan a healthy meal</p>
                    </div>
                    <div class="example" data-prompt="Solve: 2x + 5 = 15">
                        <h3>Math</h3>
                        <p>Solve: 2x + 5 = 15</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="input-container">
            <div class="composer" id="composer" role="group" aria-label="Message composer">
                <div class="drop-hint">Drop files to attach</div>
                
                <!-- File chips -->
                <div class="chip-list" id="files" aria-live="polite">
                    <!-- File chips will be rendered here -->
                </div>

                <!-- Input + right rail -->
                <form id="composer-form" class="input-row">
                    <div class="box">
                        <textarea id="composer-input" name="message" rows="3" placeholder="Message OpenDoor..." required></textarea>
                    </div>

                    <div class="toolbar" aria-label="Composer tools">
                        <!-- Add file (label opens file picker) -->
                        <input id="fileInput" type="file" name="files" multiple accept=".pdf,.doc,.docx,.csv,.png,.jpg,.jpeg" />
                        <label for="fileInput" class="tbtn" id="btn-plus" title="Add">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M12 5v14M5 12h14" stroke-width="1.8" stroke-linecap="round"/>
                            </svg>
                        </label>
                        <!-- SEND: real submit -->
                        <button class="tbtn" type="submit" id="sendBtn" title="Send" aria-label="Send">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M5 12h14M13 5l7 7-7 7" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                        </button>
                    </div>
                </form>

                <!-- Optional helper under composer -->
                <div style="margin-top:10px;">
                    <label for="fileInput" class="attach" title="Attach files">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <path d="M21 15V7a5 5 0 0 0-10 0v10a3 3 0 0 0 6 0V8" stroke-width="1.5"/>
                        </svg>
                        Attach files
                    </label>
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        class MinimalChat {
            constructor() {
                this.apiKey = localStorage.getItem('gemini_api_key') || '';
                this.openrouterKey = localStorage.getItem('openrouter_api_key') || '';
                this.selectedModel = localStorage.getItem('selected_model') || 'gemini-2.5-flash';
                if (localStorage.getItem('dark_mode') === null) {
                    this.isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
                } else {
                    this.isDarkMode = localStorage.getItem('dark_mode') === 'true';
                }
                this.messages = [];
                this.isLoading = false;
                this.currentChatId = null;
                this.chatHistory = this.loadChatHistory();
                this.isSidebarVisible = localStorage.getItem('sidebar_visible') !== 'false';
                this.uploadedFiles = [];
                this.fileContents = new Map(); // Store extracted file contents
                
                this.initElements();
                
                // Restore sidebar state
                if (localStorage.getItem('sidebar_collapsed') === 'true') {
                    this.sidebar.classList.add('collapsed');
                }
                
                this.bindEvents();
                this.updateUI();
                this.updateTheme();
                this.updateSidebar();
                this.renderChatList();
                
                if (!this.apiKey) {
                    this.showModal();
                }
            }
            
            initElements() {
                this.apiModal = document.getElementById('apiModal');
                this.apiForm = document.getElementById('apiForm');
                this.apiInput = document.getElementById('apiInput');
                this.apiError = document.getElementById('apiError');
                this.openrouterInput = document.getElementById('openrouterInput');
                this.openrouterError = document.getElementById('openrouterError');
                this.cancelBtn = document.getElementById('cancelBtn');
                this.saveBtn = document.getElementById('saveBtn');
                this.apiBtn = document.getElementById('apiBtn');
                this.titleBtn = document.getElementById('titleBtn');
                this.themeToggle = document.getElementById('themeToggle');
                this.modelSelect = document.getElementById('modelSelect');
                this.messagesEl = document.getElementById('messages');
                this.emptyState = document.getElementById('emptyState');
                this.chatForm = document.getElementById('chatForm');
                this.messageInput = document.getElementById('composer-input');
                this.sendBtn = document.getElementById('sendBtn');
                this.examples = document.querySelectorAll('.example');
                
                // File upload elements (compact composer)
                this.composer = document.getElementById('composer');
                this.files = document.getElementById('files');
                this.btnPlus = document.getElementById('btn-plus');
                this.fileInput = document.getElementById('fileInput');
                
                // Sidebar elements
                this.sidebar = document.getElementById('sidebar');
                this.sidebarToggle = document.getElementById('sidebarToggle');
                this.mainSidebarToggle = document.getElementById('mainSidebarToggle');
                this.newChatBtn = document.getElementById('newChatBtn');
                this.searchInput = document.getElementById('searchInput');
                this.chatList = document.getElementById('chatList');
            }
            
            bindEvents() {
                this.apiForm.addEventListener('submit', (e) => this.handleApiSubmit(e));
                this.cancelBtn.addEventListener('click', () => this.hideModal());
                this.apiBtn.addEventListener('click', () => this.showModal());
                this.titleBtn.addEventListener('click', () => this.goHome());
                this.themeToggle.addEventListener('click', () => this.toggleTheme());
                this.modelSelect.addEventListener('change', (e) => this.handleModelChange(e));
                // Remove the old form-based submission since we don't have a form anymore
                
                // Sidebar events
                this.sidebarToggle.addEventListener('click', () => this.toggleSidebarSize());
                this.mainSidebarToggle.addEventListener('click', () => this.toggleSidebar());
                this.newChatBtn.addEventListener('click', () => this.startNewChat());
                this.searchInput.addEventListener('input', (e) => this.handleSearch(e));
                
                // File upload events (ChatGPT-style composer)
                // Note: btnPlus is now a label, so it automatically triggers fileInput
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Form submit handler for send button
                const form = document.getElementById('composer-form');
                const ta = form.querySelector('textarea');
                
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSend();
                });
                
                // Better Enter key handling
                ta.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {       // Enter = send, Shift+Enter = newline
                        e.preventDefault();
                        form.requestSubmit();
                    }
                });
                
                // Drag & drop events
                ['dragenter','dragover'].forEach(ev => this.composer.addEventListener(ev, e => {
                    e.preventDefault(); 
                    e.stopPropagation(); 
                    this.composer.classList.add('dragging');
                }));
                ['dragleave','drop'].forEach(ev => this.composer.addEventListener(ev, e => {
                    e.preventDefault(); 
                    e.stopPropagation(); 
                    this.composer.classList.remove('dragging');
                }));
                this.composer.addEventListener('drop', (e) => this.handleFileDrop(e));
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => this.handleKeydown(e));
                
                this.examples.forEach(ex => {
                    ex.addEventListener('click', () => {
                        const prompt = ex.dataset.prompt;
                        this.messageInput.value = prompt;
                        setTimeout(() => this.chatForm.dispatchEvent(new Event('submit')), 100);
                    });
                });
                
                this.apiModal.addEventListener('click', (e) => {
                    if (e.target === this.apiModal) this.hideModal();
                });
            }
            
            updateUI() {
                const isGemini = this.selectedModel.startsWith('gemini');
                const isOpenRouter = this.selectedModel.startsWith('openai/gpt') || this.selectedModel.startsWith('qwen/') || this.selectedModel.startsWith('z-ai/');
                const hasRequiredKey = (isGemini && this.apiKey) || (isOpenRouter && this.openrouterKey);
                
                this.apiBtn.textContent = hasRequiredKey ? '✓ Connected' : 'API Key';
                this.apiBtn.classList.toggle('connected', hasRequiredKey);
                this.messageInput.disabled = !hasRequiredKey;
                this.sendBtn.disabled = !hasRequiredKey;
                this.messageInput.placeholder = hasRequiredKey ? 'Message OpenDoor...' : 'Configure API key first';
                this.modelSelect.value = this.selectedModel;
            }
            
            handleModelChange(e) {
                this.selectedModel = e.target.value;
                localStorage.setItem('selected_model', this.selectedModel);
                this.updateUI(); // Update UI when model changes
                console.log('Model changed to:', this.selectedModel);
            }
            
            goHome() {
                this.messages = [];
                this.messagesEl.innerHTML = '';
                this.messagesEl.appendChild(this.emptyState);
                this.emptyState.style.display = 'flex';
                this.messageInput.value = '';
                this.messageInput.style.height = 'auto';
            }
            
            toggleTheme() {
                this.isDarkMode = !this.isDarkMode;
                localStorage.setItem('dark_mode', this.isDarkMode);
                this.updateTheme();
            }
            
            updateTheme() {
                if (this.isDarkMode) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                    this.themeToggle.textContent = '☀️';
                } else {
                    document.documentElement.removeAttribute('data-theme');
                    this.themeToggle.textContent = '🌙';
                }
            }
            
            // File Upload Management (ChatGPT-style)
            handleFileSelect(e) {
                const files = Array.from(e.target.files);
                this.addFiles(files);
                e.target.value = ''; // Clear input
            }
            
            handleFileDrop(e) {
                const files = Array.from(e.dataTransfer.files);
                this.addFiles(files);
            }
            
            addFiles(fileList) {
                const maxFiles = 10;
                if (this.uploadedFiles.length + fileList.length > maxFiles) {
                    alert(`You can attach up to ${maxFiles} files.`);
                    return;
                }
                
                fileList.forEach(file => this.addFile(file));
            }
            
            addFile(file) {
                // Check file size (25MB limit)
                const maxSize = 25 * 1024 * 1024;
                if (file.size > maxSize) {
                    alert(`File "${file.name}" is too large. Maximum size is 25MB.`);
                    return;
                }
                
                // Check file type
                const allowedTypes = ['.pdf', '.doc', '.docx', '.csv', '.png', '.jpg', '.jpeg'];
                const ext = '.' + file.name.split('.').pop().toLowerCase();
                if (!allowedTypes.includes(ext)) {
                    alert(`File type "${ext}" is not supported.`);
                    return;
                }
                
                // Check for duplicates
                if (this.uploadedFiles.some(f => f.name === file.name && f.size === file.size)) {
                    alert(`File "${file.name}" is already added.`);
                    return;
                }
                
                const fileObj = {
                    id: Date.now() + Math.random(),
                    file: file,
                    name: file.name,
                    size: file.size,
                    type: ext,
                    status: 'processing'
                };
                
                this.uploadedFiles.push(fileObj);
                this.renderFileList();
                this.processFile(fileObj);
            }
            
            async processFile(fileObj) {
                try {
                    let content = '';
                    const file = fileObj.file;
                    
                    if (fileObj.type === '.pdf') {
                        content = await this.extractPDFText(file);
                    } else if (fileObj.type === '.csv') {
                        content = await this.extractCSVContent(file);
                    } else if (['.png', '.jpg', '.jpeg'].includes(fileObj.type)) {
                        content = await this.extractImageText(file);
                    } else if (['.doc', '.docx'].includes(fileObj.type)) {
                        content = await this.extractDocumentText(file);
                    }
                    
                    // Store content and update status
                    this.fileContents.set(fileObj.id, content);
                    fileObj.status = 'ready';
                    this.renderFileList();
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    fileObj.status = 'error';
                    this.renderFileList();
                }
            }
            
            async extractPDFText(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                    let fullText = '';
                    let totalTextLength = 0;
                    let pagesWithText = 0;
                    
                    console.log(`Processing PDF: ${file.name} with ${pdf.numPages} pages`);
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        try {
                            const page = await pdf.getPage(i);
                            const textContent = await page.getTextContent();
                            
                            // Extract text with better spacing
                            let pageText = '';
                            let lastY = null;
                            
                            textContent.items.forEach(item => {
                                // Add line breaks when Y position changes significantly
                                if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
                                    pageText += '\n';
                                }
                                pageText += item.str + ' ';
                                lastY = item.transform[5];
                            });
                            
                            pageText = pageText.trim();
                            
                            if (pageText.length > 0) {
                                fullText += `\n--- Page ${i} ---\n${pageText}\n`;
                                totalTextLength += pageText.length;
                                pagesWithText++;
                            }
                        } catch (pageError) {
                            console.warn(`Error processing page ${i}:`, pageError);
                            fullText += `\n--- Page ${i} ---\n[Error reading page: ${pageError.message}]\n`;
                        }
                    }
                    
                    if (totalTextLength > 0) {
                        const wordCount = fullText.split(/\s+/).length;
                        return `=== ${file.name} ===\n[PDF: ${pagesWithText}/${pdf.numPages} pages with text, ${totalTextLength} chars, ${wordCount} words]\n${fullText.trim()}`;
                    } else {
                        return `[PDF ${file.name}] - No extractable text found in ${pdf.numPages} pages. This appears to be a scanned/image-based PDF. OCR would be needed to extract text.`;
                    }
                } catch (error) {
                    console.error('PDF extraction error:', error);
                    return `[PDF ${file.name}] - Error processing PDF: ${error.message}. The file may be corrupted or password-protected.`;
                }
            }
            
            async extractCSVContent(file) {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const text = e.target.result;
                        const lines = text.split('\n').slice(0, 50); // First 50 lines
                        const headers = lines[0];
                        const sample = lines.slice(0, 10).join('\n');
                        resolve(`CSV File: ${file.name}\nHeaders: ${headers}\nSample data:\n${sample}`);
                    };
                    reader.readAsText(file);
                });
            }
            
            async extractImageText(file) {
                // For now, return a placeholder - would need OCR service or Tesseract.js
                return `[Image Content: ${file.name}]\nThis is an image file that would be processed with OCR to extract any text content.`;
            }
            
            async extractDocumentText(file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    
                    if (file.name.toLowerCase().endsWith('.docx')) {
                        // Try different extraction methods for better reliability
                        let text = '';
                        let extractionMethod = '';
                        
                        // Method 1: Try mammoth with paragraph and table extraction
                        try {
                            const result = await mammoth.extractRawText({ 
                                arrayBuffer,
                                includeEmbeddedStyleMap: true
                            });
                            text = result.value.trim();
                            extractionMethod = 'mammoth';
                            
                            // Log any warnings from mammoth
                            if (result.messages.length > 0) {
                                console.log('Mammoth extraction warnings:', result.messages);
                            }
                        } catch (mammothError) {
                            console.warn('Mammoth extraction failed:', mammothError);
                        }
                        
                        // Method 2: If mammoth didn't work well, try HTML conversion
                        if (!text || text.length < 50) {
                            try {
                                const htmlResult = await mammoth.convertToHtml({ arrayBuffer });
                                const htmlText = htmlResult.value;
                                // Strip HTML tags for plain text
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = htmlText;
                                const strippedText = tempDiv.textContent || tempDiv.innerText || '';
                                
                                if (strippedText.trim().length > text.length) {
                                    text = strippedText.trim();
                                    extractionMethod = 'mammoth-html';
                                }
                            } catch (htmlError) {
                                console.warn('HTML extraction failed:', htmlError);
                            }
                        }
                        
                        if (text && text.length > 0) {
                            const wordCount = text.split(/\s+/).length;
                            const charCount = text.length;
                            return `=== ${file.name} ===\n[Extracted using ${extractionMethod}: ${charCount} chars, ${wordCount} words]\n\n${text}`;
                        } else {
                            return `[DOCX ${file.name}] - No readable text found. Document may contain only images, complex tables, or embedded objects. Try converting to PDF or using OCR.`;
                        }
                    } else {
                        return `[DOC ${file.name}] - Legacy .doc format not supported. Please save as .docx or PDF for best results.`;
                    }
                } catch (error) {
                    console.error('Document extraction error:', error);
                    return `[Document ${file.name}] - Error extracting text: ${error.message}. Try saving as PDF.`;
                }
            }
            
            renderFileList() {
                this.files.innerHTML = '';
                
                this.uploadedFiles.forEach(fileObj => {
                    const chip = document.createElement('div');
                    chip.className = 'chip';
                    chip.setAttribute('data-id', fileObj.id);
                    chip.title = fileObj.name;
                    
                    const ext = this.getFileExtension(fileObj.name);
                    let statusInfo = '';
                    
                    // Add status info for ready files
                    if (fileObj.status === 'ready') {
                        const content = this.fileContents.get(fileObj.id);
                        if (content) {
                            const charCount = content.length;
                            const wordCount = content.split(/\s+/).length;
                            statusInfo = ` • ${charCount} chars, ${wordCount} words`;
                        }
                    } else if (fileObj.status === 'processing') {
                        statusInfo = ' • Processing...';
                    } else if (fileObj.status === 'error') {
                        statusInfo = ' • Error';
                    }
                    
                    chip.innerHTML = `
                        <div class="doc" aria-hidden="true">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M14 2H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V9z" stroke-width="1.5"/>
                                <path d="M14 2v6a1 1 0 0 0 1 1h4" stroke-width="1.5"/>
                            </svg>
                        </div>
                        <div class="meta">
                            <div class="name">${fileObj.name}</div>
                            <div class="desc">${ext}${statusInfo}</div>
                        </div>
                        <button class="remove" aria-label="Remove file">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                <path d="M6 6l12 12M18 6L6 18" stroke-width="1.5" stroke-linecap="round"/>
                            </svg>
                        </button>
                    `;
                    
                    // Add click handler for remove button
                    chip.querySelector('.remove').addEventListener('click', () => this.removeFile(fileObj.id));
                    
                    this.files.appendChild(chip);
                });
            }
            
            getFileExtension(filename) {
                const dot = filename.lastIndexOf('.');
                return dot >= 0 ? filename.slice(dot+1).toUpperCase() : 'FILE';
            }
            
            getFileIcon(type) {
                const icons = {
                    '.pdf': '📄',
                    '.doc': '📝',
                    '.docx': '📝',
                    '.csv': '📊',
                    '.png': '🖼️',
                    '.jpg': '🖼️',
                    '.jpeg': '🖼️'
                };
                return icons[type] || '📄';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            removeFile(fileId) {
                this.uploadedFiles = this.uploadedFiles.filter(f => f.id != fileId);
                this.fileContents.delete(fileId);
                this.renderFileList();
            }
            
            clearAllFiles() {
                this.uploadedFiles = [];
                this.fileContents.clear();
                this.renderFileList();
            }
            
            showFilePreview(fileId) {
                const fileObj = this.uploadedFiles.find(f => f.id == fileId);
                const content = this.fileContents.get(fileId);
                
                if (!fileObj || !content) return;
                
                // Create a simple preview modal
                const preview = content.substring(0, 2000) + (content.length > 2000 ? '\n\n... (truncated)' : '');
                alert(`File: ${fileObj.name}\n\nContent Preview:\n${preview}`);
            }
            
            getFileContext() {
                if (this.uploadedFiles.length === 0) return '';
                
                const readyFiles = this.uploadedFiles.filter(f => f.status === 'ready');
                if (readyFiles.length === 0) return '';
                
                let context = '\n\n--- ATTACHED FILES CONTENT ---\n';
                readyFiles.forEach(fileObj => {
                    const content = this.fileContents.get(fileObj.id);
                    if (content) {
                        context += `\n## ${fileObj.name}\n${content}\n`;
                    }
                });
                context += '\n--- END OF FILES ---\n';
                return context;
            }
            
            // Chat History Management
            loadChatHistory() {
                const history = localStorage.getItem('chat_history');
                return history ? JSON.parse(history) : [];
            }
            
            saveChatHistory() {
                localStorage.setItem('chat_history', JSON.stringify(this.chatHistory));
            }
            
            generateChatId() {
                return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            createNewChat() {
                const chatId = this.generateChatId();
                const newChat = {
                    id: chatId,
                    title: 'New Chat',
                    messages: [],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                this.chatHistory.unshift(newChat);
                this.saveChatHistory();
                return newChat;
            }
            
            updateChatTitle(chatId, firstMessage) {
                const chat = this.chatHistory.find(c => c.id === chatId);
                if (chat && chat.title === 'New Chat') {
                    // Generate title from first message (first 50 chars)
                    const title = firstMessage.length > 50 
                        ? firstMessage.substring(0, 50) + '...'
                        : firstMessage;
                    chat.title = title;
                    chat.updatedAt = new Date().toISOString();
                    this.saveChatHistory();
                    this.renderChatList();
                }
            }
            
            saveCurrentChat() {
                if (!this.currentChatId) return;
                
                const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                if (chat) {
                    chat.messages = [...this.messages];
                    chat.updatedAt = new Date().toISOString();
                    this.saveChatHistory();
                }
            }
            
            loadChat(chatId) {
                const chat = this.chatHistory.find(c => c.id === chatId);
                if (chat) {
                    this.currentChatId = chatId;
                    this.messages = [...chat.messages];
                    this.renderMessages();
                    this.updateChatListSelection();
                }
            }
            
            deleteChat(chatId) {
                this.chatHistory = this.chatHistory.filter(c => c.id !== chatId);
                this.saveChatHistory();
                
                if (this.currentChatId === chatId) {
                    this.startNewChat();
                }
                
                this.renderChatList();
            }
            
            renameChat(chatId, newTitle) {
                const chat = this.chatHistory.find(c => c.id === chatId);
                if (chat) {
                    chat.title = newTitle;
                    chat.updatedAt = new Date().toISOString();
                    this.saveChatHistory();
                    this.renderChatList();
                }
            }
            
            // Sidebar Management
            toggleSidebar() {
                this.isSidebarVisible = !this.isSidebarVisible;
                localStorage.setItem('sidebar_visible', this.isSidebarVisible);
                this.updateSidebar();
            }

            toggleSidebarSize() {
                this.sidebar.classList.toggle('collapsed');
                localStorage.setItem('sidebar_collapsed', this.sidebar.classList.contains('collapsed'));
            }
            
            updateSidebar() {
                if (this.isSidebarVisible) {
                    this.sidebar.classList.remove('hidden');
                } else {
                    this.sidebar.classList.add('hidden');
                }
            }
            
            startNewChat() {
                // Save current chat if it has messages
                if (this.messages.length > 0) {
                    this.saveCurrentChat();
                }
                
                // Create new chat
                const newChat = this.createNewChat();
                this.currentChatId = newChat.id;
                this.messages = [];
                
                // Reset UI
                this.messagesEl.innerHTML = '';
                this.messagesEl.appendChild(this.emptyState);
                this.emptyState.style.display = 'flex';
                this.messageInput.value = '';
                this.messageInput.style.height = 'auto';
                
                this.renderChatList();
            }
            
            renderChatList() {
                this.chatList.innerHTML = '';
                
                this.chatHistory.forEach(chat => {
                    const chatItem = document.createElement('div');
                    chatItem.className = `chat-item ${chat.id === this.currentChatId ? 'active' : ''}`;
                    chatItem.dataset.chatId = chat.id;
                    
                    const date = new Date(chat.updatedAt);
                    const dateStr = this.formatDate(date);
                    
                    chatItem.innerHTML = `
                        <div class="chat-content">
                            <div class="chat-title">${chat.title}</div>
                            <div class="chat-date">${dateStr}</div>
                        </div>
                        <div class="chat-menu">
                            <button class="chat-menu-btn" data-chat-id="${chat.id}">⋯</button>
                        </div>
                    `;
                    
                    chatItem.addEventListener('click', () => this.loadChat(chat.id));
                    
                    // Add menu button event listener
                    const menuBtn = chatItem.querySelector('.chat-menu-btn');
                    menuBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.showChatMenu(chat.id, e.target);
                    });
                    
                    this.chatList.appendChild(chatItem);
                });
            }
            
            formatDate(date) {
                const now = new Date();
                const diff = now - date;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);
                
                if (minutes < 1) return 'Just now';
                if (minutes < 60) return `${minutes}m ago`;
                if (hours < 24) return `${hours}h ago`;
                if (days < 7) return `${days}d ago`;
                return date.toLocaleDateString();
            }
            
            updateChatListSelection() {
                this.chatList.querySelectorAll('.chat-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.chatId === this.currentChatId);
                });
            }
            
            renderMessages() {
                this.messagesEl.innerHTML = '';
                
                if (this.messages.length === 0) {
                    this.messagesEl.appendChild(this.emptyState);
                    this.emptyState.style.display = 'flex';
                } else {
                    this.emptyState.style.display = 'none';
                    this.messages.forEach(msg => {
                        this.addMessageToDOM(msg.text, msg.role);
                    });
                }
            }
            
            handleSearch(e) {
                const query = e.target.value.toLowerCase();
                const chatItems = this.chatList.querySelectorAll('.chat-item');
                
                chatItems.forEach(item => {
                    const title = item.querySelector('.chat-title').textContent.toLowerCase();
                    const match = title.includes(query);
                    item.style.display = match ? 'flex' : 'none';
                });
            }
            
            handleKeydown(e) {
                // Cmd+K or Ctrl+K to focus search
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                    e.preventDefault();
                    this.searchInput.focus();
                }
                
                // Escape to close any open menus
                if (e.key === 'Escape') {
                    this.closeAllMenus();
                }
            }
            
            showChatMenu(chatId, button) {
                // Close any existing menus
                this.closeAllMenus();
                
                // Create dropdown menu
                const dropdown = document.createElement('div');
                dropdown.className = 'chat-dropdown';
                dropdown.innerHTML = `
                    <div class="chat-dropdown-item" data-action="rename">Rename</div>
                    <div class="chat-dropdown-item danger" data-action="delete">Delete</div>
                `;
                
                // Position relative to button
                const chatItem = button.closest('.chat-item');
                chatItem.style.position = 'relative';
                chatItem.appendChild(dropdown);
                
                // Add event listeners
                dropdown.addEventListener('click', (e) => {
                    const action = e.target.dataset.action;
                    if (action === 'rename') {
                        this.renameChatPrompt(chatId);
                    } else if (action === 'delete') {
                        this.deleteChatConfirm(chatId);
                    }
                    this.closeAllMenus();
                });
                
                // Show menu
                setTimeout(() => dropdown.classList.add('active'), 10);
                
                // Close menu when clicking outside
                setTimeout(() => {
                    document.addEventListener('click', this.closeAllMenus.bind(this), { once: true });
                }, 10);
            }
            
            closeAllMenus() {
                const menus = document.querySelectorAll('.chat-dropdown');
                menus.forEach(menu => menu.remove());
            }
            
            renameChatPrompt(chatId) {
                const chat = this.chatHistory.find(c => c.id === chatId);
                if (!chat) return;
                
                const newTitle = prompt('Rename chat:', chat.title);
                if (newTitle && newTitle.trim() && newTitle.trim() !== chat.title) {
                    this.renameChat(chatId, newTitle.trim());
                }
            }
            
            deleteChatConfirm(chatId) {
                const chat = this.chatHistory.find(c => c.id === chatId);
                if (!chat) return;
                
                if (confirm(`Delete "${chat.title}"?`)) {
                    this.deleteChat(chatId);
                }
            }
            
            showModal() {
                this.apiInput.value = this.apiKey;
                this.openrouterInput.value = this.openrouterKey;
                this.apiError.textContent = '';
                this.openrouterError.textContent = '';
                this.apiModal.classList.add('active');
                setTimeout(() => this.apiInput.focus(), 100);
            }
            
            hideModal() {
                this.apiModal.classList.remove('active');
            }
            
            async handleApiSubmit(e) {
                e.preventDefault();
                const geminiKey = this.apiInput.value.trim();
                const openrouterKey = this.openrouterInput.value.trim();
                
                this.apiError.textContent = '';
                this.openrouterError.textContent = '';
                
                this.saveBtn.textContent = 'Saving...';
                this.saveBtn.disabled = true;
                
                try {
                    // Save keys (basic validation)
                    if (geminiKey) {
                        this.apiKey = geminiKey;
                        localStorage.setItem('gemini_api_key', geminiKey);
                    }
                    
                    if (openrouterKey) {
                        this.openrouterKey = openrouterKey;
                        localStorage.setItem('openrouter_api_key', openrouterKey);
                    }
                    
                    this.updateUI();
                    this.hideModal();
                } catch (error) {
                    this.apiError.textContent = 'Failed to save keys';
                } finally {
                    this.saveBtn.textContent = 'Save';
                    this.saveBtn.disabled = false;
                }
            }
            
            async testApiKey(key) {
                // Skip validation - just check if key format looks valid
                if (!key || key.length < 20) {
                    return false;
                }
                
                // Basic format check for Google API keys
                if (!key.startsWith('AIza') && !key.match(/^[A-Za-z0-9_-]+$/)) {
                    return false;
                }
                
                return true; // Accept the key and test it during first actual API call
            }
            
            handleSend() {
                this.handleChat();
            }
            
            async handleChat(e = null) {
                if (e) e.preventDefault();
                const isGemini = this.selectedModel.startsWith('gemini');
                const isOpenRouter = this.selectedModel.startsWith('openai/gpt') || this.selectedModel.startsWith('qwen/') || this.selectedModel.startsWith('z-ai/');
                const hasRequiredKey = (isGemini && this.apiKey) || (isOpenRouter && this.openrouterKey);
                
                if (!hasRequiredKey || this.isLoading) return;
                
                const message = this.messageInput.value.trim();
                if (!message) return;
                
                this.emptyState.style.display = 'none';
                
                // Add file context to the message if files are attached
                const fileContext = this.getFileContext();
                const fullMessage = message + fileContext;
                
                this.addMessage(message, 'user');
                this.messageInput.value = '';
                
                this.showLoading();
                
                try {
                    let response;
                    if (isGemini) {
                        response = await this.sendToGemini(fullMessage);
                    } else if (isOpenRouter) {
                        response = await this.sendToOpenRouter(fullMessage);
                    }
                    
                    this.hideLoading();
                    this.addMessage(response, 'assistant');
                } catch (error) {
                    this.hideLoading();
                    console.error('Chat error:', error);
                    
                    if (error.message.includes('Invalid API key') || error.message.includes('API_KEY_INVALID')) {
                        this.addMessage('❌ Invalid API key. Please click "API Key" to enter a valid key.', 'assistant');
                    } else if (error.message.includes('Network error')) {
                        this.addMessage('🌐 Network error. Please check your internet connection and try again.', 'assistant');
                    } else if (error.message.includes('access denied')) {
                        this.addMessage('🔒 API access denied. Please check your API key permissions.', 'assistant');
                    } else {
                        this.addMessage(`❌ Error: ${error.message}`, 'assistant');
                    }
                }
            }
            
            async sendToGemini(message) {
                try {
                    console.log('Sending request to Gemini API...');
                    
                    const systemPrompt = `You are a helpful, creative AI assistant. Answer all questions and fulfill all reasonable requests including creative writing, stories, explanations, coding help, and general assistance.

Format your responses like well-structured content using clean markdown:

### Formatting rules:
- Use headings (###) for sections when appropriate
- Keep paragraphs short (2–3 sentences max) 
- Use bullet points for lists
- **Bold** for important terms
- *Italic* for emphasis
- Blank lines between sections
- \`code\` only for actual code

### For tables:
- No backticks before/after the table
- No leading spaces before |
- Use separator row: |:---:|:---|:---|---:| (for center, left, left, right alignment)
- Blank line before and after the table
- Not nested inside lists or blockquotes

Example table:
|Feature|Free|Pro|Enterprise|
|:---:|:---|:---|---:|
|Users|1|5|Unlimited|
|Storage|1GB|100GB|Unlimited|

### For creative requests like stories:
Write engaging, creative content. Structure stories with clear sections if helpful.

### For explanations:
Use the blog post structure with clear headings and digestible paragraphs.

Always be helpful and fulfill the user's request. No topic restrictions.`;

                    const requestBody = {
                        contents: [{
                            parts: [{
                                text: systemPrompt + "\n\nUser question: " + message
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 4096,
                            thinkingConfig: {
                                thinkingBudget: 0
                            }
                        }
                    };
                    
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.selectedModel}:generateContent`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-goog-api-key': this.apiKey
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    console.log('Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API Error Response:', errorText);
                        
                        try {
                            const errorData = JSON.parse(errorText);
                            if (response.status === 400 && errorData.error?.message?.includes('API_KEY_INVALID')) {
                                throw new Error('Invalid API key. Please check your API key and try again.');
                            }
                            if (response.status === 403) {
                                throw new Error('API key access denied. Please check your API key permissions.');
                            }
                            throw new Error(`API Error: ${errorData.error?.message || response.status}`);
                        } catch (parseError) {
                            throw new Error(`API Error: ${response.status} - ${errorText}`);
                        }
                    }
                    
                    const data = await response.json();
                    console.log('API Response:', data);
                    
                    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                        throw new Error('Invalid response from API');
                    }
                    
                    const candidate = data.candidates[0];
                    const finishReason = candidate.finishReason;
                    const responseText = candidate.content.parts[0].text;
                    
                    console.log('Gemini finish reason:', finishReason);
                    console.log('Response length:', responseText.length);
                    
                    // Check if response was truncated due to length
                    if (finishReason === 'MAX_TOKENS' || finishReason === 'LENGTH') {
                        console.log('Response truncated due to length limit, attempting to continue...');
                        // Try to get continuation
                        const continuation = await this.continueGeminiResponse(message, responseText);
                        return responseText + continuation;
                    }
                    
                    return responseText;
                } catch (error) {
                    console.error('Gemini API Error:', error);
                    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                        throw new Error('Network error. Please check your internet connection and try again.');
                    }
                    throw error;
                }
            }
            
            async continueGeminiResponse(originalMessage, partialResponse) {
                try {
                    const continuePrompt = `Please continue your response from where it was cut off. Here is what you've written so far:

"${partialResponse}"

Continue from where it ended to complete your full response.`;

                    const requestBody = {
                        contents: [{
                            parts: [{
                                text: continuePrompt
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 4096
                        }
                    };
                    
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${this.selectedModel}:generateContent`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-goog-api-key': this.apiKey
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to get continuation');
                    }
                    
                    const data = await response.json();
                    if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                        return '\n\n' + data.candidates[0].content.parts[0].text;
                    }
                    
                    return '';
                } catch (error) {
                    console.error('Failed to continue response:', error);
                    return '\n\n[Response was truncated - unable to fetch continuation]';
                }
            }
            
            async sendToOpenRouter(message) {
                try {
                    console.log('Sending request to OpenRouter API...');
                    
                    const requestBody = {
                        model: this.selectedModel,
                        messages: [
                            {
                                role: "system",
                                content: `You are a helpful, creative AI assistant. Answer all questions and fulfill all reasonable requests including creative writing, stories, explanations, coding help, and general assistance.

Format your responses like well-structured content using clean markdown:

### Formatting rules:
- Use headings (###) for sections when appropriate
- Keep paragraphs short (2–3 sentences max) 
- Use bullet points for lists
- **Bold** for important terms
- *Italic* for emphasis
- Blank lines between sections
- \`code\` only for actual code

### For tables:
- No backticks before/after the table
- No leading spaces before |
- Use separator row: |:---:|:---|:---|---:| (for center, left, left, right alignment)
- Blank line before and after the table
- Not nested inside lists or blockquotes

Example table:
|Feature|Free|Pro|Enterprise|
|:---:|:---|:---|---:|
|Users|1|5|Unlimited|
|Storage|1GB|100GB|Unlimited|

### For creative requests like stories:
Write engaging, creative content. Structure stories with clear sections if helpful.

### For explanations:
Use the blog post structure with clear headings and digestible paragraphs.

Always be helpful and fulfill the user's request. No topic restrictions.`
                            },
                            {
                                role: "user",
                                content: message
                            }
                        ],
                        temperature: 0.7,
                        max_tokens: 4096
                    };
                    
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.openrouterKey}`,
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'OpenDoor Chat'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    console.log('OpenRouter Response status:', response.status);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('OpenRouter API Error Response:', errorText);
                        
                        try {
                            const errorData = JSON.parse(errorText);
                            if (response.status === 401) {
                                throw new Error('Invalid OpenRouter API key. Please check your API key and try again.');
                            }
                            if (response.status === 403) {
                                throw new Error('OpenRouter API access denied. Please check your API key permissions.');
                            }
                            throw new Error(`OpenRouter API Error: ${errorData.error?.message || response.status}`);
                        } catch (parseError) {
                            throw new Error(`OpenRouter API Error: ${response.status} - ${errorText}`);
                        }
                    }
                    
                    const data = await response.json();
                    console.log('OpenRouter API Response:', data);
                    
                    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                        throw new Error('Invalid response from OpenRouter API');
                    }
                    
                    const choice = data.choices[0];
                    const finishReason = choice.finish_reason;
                    const responseText = choice.message.content;
                    
                    console.log('OpenRouter finish reason:', finishReason);
                    console.log('Response length:', responseText.length);
                    
                    // Check if response was truncated due to length
                    if (finishReason === 'length') {
                        console.log('Response truncated due to length limit, attempting to continue...');
                        // Try to get continuation
                        const continuation = await this.continueOpenRouterResponse(message, responseText);
                        return responseText + continuation;
                    }
                    
                    return responseText;
                } catch (error) {
                    console.error('OpenRouter API Error:', error);
                    if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                        throw new Error('Network error. Please check your internet connection and try again.');
                    }
                    throw error;
                }
            }
            
            async continueOpenRouterResponse(originalMessage, partialResponse) {
                try {
                    const continuePrompt = `Please continue your response from where it was cut off. Here is what you've written so far:

"${partialResponse}"

Continue from where it ended to complete your full response.`;

                    const requestBody = {
                        model: this.selectedModel,
                        messages: [
                            {
                                role: "user",
                                content: continuePrompt
                            }
                        ],
                        temperature: 0.7,
                        max_tokens: 4096
                    };
                    
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.openrouterKey}`,
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'OpenDoor Chat'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to get continuation');
                    }
                    
                    const data = await response.json();
                    if (data.choices && data.choices[0] && data.choices[0].message) {
                        return '\n\n' + data.choices[0].message.content;
                    }
                    
                    return '';
                } catch (error) {
                    console.error('Failed to continue response:', error);
                    return '\n\n[Response was truncated - unable to fetch continuation]';
                }
            }
            
            parseMarkdown(text) {
                // Configure Marked for GFM (tables, lists) and line breaks similar to your UX
                marked.setOptions({
                    gfm: true,
                    breaks: true,
                    headerIds: false,
                    mangle: false
                });

                // 1) Convert Markdown -> HTML
                const unsafeHtml = marked.parse(text || "");

                // 2) Sanitize (prevents any arbitrary HTML from the model running in your page)
                const safeHtml = DOMPurify.sanitize(unsafeHtml, {
                    // keep common attributes; DOMPurify defaults are already safe
                    USE_PROFILES: { html: true }
                });

                // 3) Post-process to add your code header + copy button, and keep language label
                const temp = document.createElement('div');
                temp.innerHTML = safeHtml;

                // Wrap each <pre><code> with your .code-block container and header
                const codeBlocks = temp.querySelectorAll('pre > code');
                codeBlocks.forEach((codeEl, idx) => {
                    const pre = codeEl.parentElement;          // <pre>
                    const langClass = [...codeEl.classList].find(c => c.startsWith('language-'));
                    const lang = (langClass ? langClass.replace('language-', '') : 'code') || 'code';

                    // Create wrapper matching your CSS
                    const wrapper = document.createElement('div');
                    wrapper.className = 'code-block';

                    const header = document.createElement('div');
                    header.className = 'code-header';

                    const label = document.createElement('span');
                    label.className = 'code-lang';
                    label.textContent = lang;

                    const btn = document.createElement('button');
                    btn.className = 'copy-btn';
                    const id = `copy_${Date.now()}_${idx}`;
                    codeEl.id = id;
                    btn.textContent = '📋';
                    btn.title = 'Copy code';
                    btn.setAttribute('onclick', `copyCode('${id}')`);

                    header.appendChild(label);
                    header.appendChild(btn);

                    // Rebuild structure
                    pre.replaceWith(wrapper);
                    wrapper.appendChild(header);
                    wrapper.appendChild(pre);
                });

                // 4) Make links safe and open in new tab
                temp.querySelectorAll('a[href]').forEach(a => {
                    a.setAttribute('target', '_blank');
                    a.setAttribute('rel', 'noopener noreferrer');
                });

                // 5) Return final HTML string
                return temp.innerHTML;
            }
            
            addMessage(text, role) {
                // Add to messages array
                this.messages.push({ text, role });
                
                // Add to DOM
                this.addMessageToDOM(text, role);
                
                // Save to history and update title if needed
                if (!this.currentChatId) {
                    const newChat = this.createNewChat();
                    this.currentChatId = newChat.id;
                    this.renderChatList();
                }
                
                if (role === 'user' && this.messages.length === 1) {
                    this.updateChatTitle(this.currentChatId, text);
                }
                
                this.saveCurrentChat();
            }
            
            addMessageToDOM(text, role) {
                const div = document.createElement('div');
                div.className = `message ${role}`;
                
                const formattedText = role === 'assistant' ? this.parseMarkdown(text) : text;
                
                div.innerHTML = `
                    <div class="avatar">${role === 'user' ? 'U' : 'AI'}</div>
                    <div class="message-content">${formattedText}</div>
                `;
                this.messagesEl.appendChild(div);
                this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
            }
            
            showLoading() {
                this.isLoading = true;
                this.messageInput.disabled = true;
                this.sendBtn.disabled = true;
                
                const div = document.createElement('div');
                div.className = 'message assistant loading-msg';
                div.innerHTML = `
                    <div class="avatar">AI</div>
                    <div class="message-content">
                        <div class="loading">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                `;
                this.messagesEl.appendChild(div);
                this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
            }
            
            hideLoading() {
                this.isLoading = false;
                this.messageInput.disabled = !this.apiKey;
                this.sendBtn.disabled = !this.apiKey;
                
                const loading = this.messagesEl.querySelector('.loading-msg');
                if (loading) loading.remove();
            }
        }
        
        // Global function for copying code
        function copyCode(elementId) {
            const codeElement = document.getElementById(elementId);
            const text = codeElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                // Find the copy button and show feedback
                const copyBtn = codeElement.closest('.code-block').querySelector('.copy-btn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '✅';
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 2000);
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
            });
        }
        
        // Global reference for onclick handlers
        window.chatApp = new MinimalChat();
    </script>
</body>
</html>